<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.2" xml:lang="en-US">
  <compounddef id="vulkan_guide" kind="page">
    <compoundname>vulkan_guide</compoundname>
    <title>Vulkan guide</title>
    <tableofcontents>
      <tocsect>
        <name>Linking against the Vulkan loader</name>
        <reference>vulkan_guide_1vulkan_loader</reference>
    </tocsect>
      <tocsect>
        <name>Including the Vulkan and GLFW header files</name>
        <reference>vulkan_guide_1vulkan_include</reference>
    </tocsect>
      <tocsect>
        <name>Querying for Vulkan support</name>
        <reference>vulkan_guide_1vulkan_support</reference>
    <tableofcontents>
      <tocsect>
        <name>Querying Vulkan function pointers</name>
        <reference>vulkan_guide_1vulkan_proc</reference>
    </tocsect>
    </tableofcontents>
    </tocsect>
      <tocsect>
        <name>Querying required Vulkan extensions</name>
        <reference>vulkan_guide_1vulkan_ext</reference>
    </tocsect>
      <tocsect>
        <name>Querying for Vulkan presentation support</name>
        <reference>vulkan_guide_1vulkan_present</reference>
    </tocsect>
      <tocsect>
        <name>Creating the window</name>
        <reference>vulkan_guide_1vulkan_window</reference>
    </tocsect>
      <tocsect>
        <name>Creating a Vulkan window surface</name>
        <reference>vulkan_guide_1vulkan_surface</reference>
    </tocsect>
    </tableofcontents>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>This guide is intended to fill the gaps between the official <ulink url="https://www.khronos.org/vulkan/">Vulkan resources</ulink> and the rest of the GLFW documentation and is not a replacement for either. It assumes some familiarity with Vulkan concepts like loaders, devices, queues and surfaces and leaves it to the Vulkan documentation to explain the details of Vulkan functions.</para>
<para>To develop for Vulkan you should download the <ulink url="https://vulkan.lunarg.com/">LunarG Vulkan SDK</ulink> for your platform. Apart from headers and link libraries, they also provide the validation layers necessary for development.</para>
<para>The <ulink url="https://vulkan-tutorial.com/">Vulkan Tutorial</ulink> has more information on how to use GLFW and Vulkan. The <ulink url="https://github.com/KhronosGroup/Vulkan-Samples">Khronos Vulkan Samples</ulink> also use GLFW, although with a small framework in between.</para>
<para>For details on a specific Vulkan support function, see the <ref refid="group__vulkan" kindref="compound">Vulkan support reference</ref>. There are also guides for the other areas of the GLFW API.</para>
<para><itemizedlist>
<listitem><para><ref refid="intro_guide" kindref="compound">Introduction to the API</ref></para>
</listitem><listitem><para><ref refid="window_guide" kindref="compound">Window guide</ref></para>
</listitem><listitem><para><ref refid="context_guide" kindref="compound">Context guide</ref></para>
</listitem><listitem><para><ref refid="monitor_guide" kindref="compound">Monitor guide</ref></para>
</listitem><listitem><para><ref refid="input_guide" kindref="compound">Input guide</ref></para>
</listitem></itemizedlist>
</para>
<sect1 id="vulkan_guide_1vulkan_loader">
<title>Linking against the Vulkan loader</title>
<para>By default, GLFW will look for the Vulkan loader on demand at runtime via its standard name (<computeroutput>vulkan-1.dll</computeroutput> on Windows, <computeroutput>libvulkan.so.1</computeroutput> on Linux and other Unix-like systems and <computeroutput>libvulkan.1.dylib</computeroutput> on macOS). This means that GLFW does not need to be linked against the loader. However, it also means that if you are using the static library form of the Vulkan loader GLFW will either fail to find it or (worse) use the wrong one.</para>
<para>The <ref refid="compile_guide_1GLFW_VULKAN_STATIC" kindref="member">GLFW_VULKAN_STATIC</ref> CMake option makes GLFW call the Vulkan loader directly instead of dynamically loading it at runtime. Not linking against the Vulkan loader will then be a compile-time error.</para>
<para>@macos Because the Vulkan loader and ICD are not installed globally on macOS, you need to set up the application bundle according to the LunarG SDK documentation. This is explained in more detail in the <ulink url="https://vulkan.lunarg.com/doc/sdk/latest/mac/getting_started.html">SDK documentation for macOS</ulink>.</para>
</sect1>
<sect1 id="vulkan_guide_1vulkan_include">
<title>Including the Vulkan and GLFW header files</title>
<para>To include the Vulkan header, define <ref refid="build_guide_1GLFW_INCLUDE_VULKAN" kindref="member">GLFW_INCLUDE_VULKAN</ref> before including the GLFW header.</para>
<para><programlisting><codeline><highlight class="preprocessor">#define<sp/>GLFW_INCLUDE_VULKAN</highlight></codeline>
<codeline><highlight class="preprocessor">#include<sp/>&lt;GLFW/glfw3.h&gt;</highlight></codeline>
</programlisting></para>
<para>If you instead want to include the Vulkan header from a custom location or use your own custom Vulkan header then do this before the GLFW header.</para>
<para><programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;path/to/vulkan.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;GLFW/glfw3.h&gt;</highlight></codeline>
</programlisting></para>
<para>Unless a Vulkan header is included, either by the GLFW header or above it, any GLFW functions that take or return Vulkan types will not be declared.</para>
<para>The <computeroutput>VK_USE_PLATFORM_*_KHR</computeroutput> macros do not need to be defined for the Vulkan part of GLFW to work. Define them only if you are using these extensions directly.</para>
</sect1>
<sect1 id="vulkan_guide_1vulkan_support">
<title>Querying for Vulkan support</title>
<para>If you are linking directly against the Vulkan loader then you can skip this section. The canonical desktop loader library exports all Vulkan core and Khronos extension functions, allowing them to be called directly.</para>
<para>If you are loading the Vulkan loader dynamically instead of linking directly against it, you can check for the availability of a loader and ICD with <ref refid="group__vulkan_1ga72e7c3757d9ff2333181a5569bb7c403" kindref="member">glfwVulkanSupported</ref>.</para>
<para><programlisting><codeline><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__vulkan_1ga72e7c3757d9ff2333181a5569bb7c403" kindref="member">glfwVulkanSupported</ref>())</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Vulkan<sp/>is<sp/>available,<sp/>at<sp/>least<sp/>for<sp/>compute</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>This function returns <computeroutput>GLFW_TRUE</computeroutput> if the Vulkan loader and any minimally functional ICD was found.</para>
<para>If one or both were not found, calling any other Vulkan related GLFW function will generate a <ref refid="group__errors_1ga56882b290db23261cc6c053c40c2d08e" kindref="member">GLFW_API_UNAVAILABLE</ref> error.</para>
<sect2 id="vulkan_guide_1vulkan_proc">
<title>Querying Vulkan function pointers</title>
<para>To load any Vulkan core or extension function from the found loader, call glfwGetInstanceProcAddress. To load functions needed for instance creation, pass <computeroutput>NULL</computeroutput> as the instance.</para>
<para><programlisting><codeline><highlight class="normal">PFN_vkCreateInstance<sp/>pfnCreateInstance<sp/>=<sp/>(PFN_vkCreateInstance)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>glfwGetInstanceProcAddress(NULL,<sp/></highlight><highlight class="stringliteral">&quot;vkCreateInstance&quot;</highlight><highlight class="normal">);</highlight></codeline>
</programlisting></para>
<para>Once you have created an instance, you can load from it all other Vulkan core functions and functions from any instance extensions you enabled.</para>
<para><programlisting><codeline><highlight class="normal">PFN_vkCreateDevice<sp/>pfnCreateDevice<sp/>=<sp/>(PFN_vkCreateDevice)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>glfwGetInstanceProcAddress(instance,<sp/></highlight><highlight class="stringliteral">&quot;vkCreateDevice&quot;</highlight><highlight class="normal">);</highlight></codeline>
</programlisting></para>
<para>This function in turn calls <computeroutput>vkGetInstanceProcAddr</computeroutput>. If that fails, the function falls back to a platform-specific query of the Vulkan loader (i.e. <computeroutput>dlsym</computeroutput> or <computeroutput>GetProcAddress</computeroutput>). If that also fails, the function returns <computeroutput>NULL</computeroutput>. For more information about <computeroutput>vkGetInstanceProcAddr</computeroutput>, see the Vulkan documentation.</para>
<para>Vulkan also provides <computeroutput>vkGetDeviceProcAddr</computeroutput> for loading device-specific versions of Vulkan function. This function can be retrieved from an instance with glfwGetInstanceProcAddress.</para>
<para><programlisting><codeline><highlight class="normal">PFN_vkGetDeviceProcAddr<sp/>pfnGetDeviceProcAddr<sp/>=<sp/>(PFN_vkGetDeviceProcAddr)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>glfwGetInstanceProcAddress(instance,<sp/></highlight><highlight class="stringliteral">&quot;vkGetDeviceProcAddr&quot;</highlight><highlight class="normal">);</highlight></codeline>
</programlisting></para>
<para>Device-specific functions may execute a little bit faster, due to not having to dispatch internally based on the device passed to them. For more information about <computeroutput>vkGetDeviceProcAddr</computeroutput>, see the Vulkan documentation.</para>
</sect2>
</sect1>
<sect1 id="vulkan_guide_1vulkan_ext">
<title>Querying required Vulkan extensions</title>
<para>To do anything useful with Vulkan you need to create an instance. If you want to use Vulkan to render to a window, you must enable the instance extensions GLFW requires to create Vulkan surfaces.</para>
<para>To query the instance extensions required, call <ref refid="group__vulkan_1gada152edc5bbbd0c2138728878632fd9c" kindref="member">glfwGetRequiredInstanceExtensions</ref>.</para>
<para><programlisting><codeline><highlight class="normal">uint32_t<sp/>count;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>extensions<sp/>=<sp/><ref refid="group__vulkan_1gada152edc5bbbd0c2138728878632fd9c" kindref="member">glfwGetRequiredInstanceExtensions</ref>(&amp;count);</highlight></codeline>
</programlisting></para>
<para>These extensions must all be enabled when creating instances that are going to be passed to glfwGetPhysicalDevicePresentationSupport and glfwCreateWindowSurface. The set of extensions will vary depending on platform and may also vary depending on graphics drivers and other factors.</para>
<para>If it fails it will return <computeroutput>NULL</computeroutput> and GLFW will not be able to create Vulkan window surfaces. You can still use Vulkan for off-screen rendering and compute work.</para>
<para>If successful the returned array will always include <computeroutput>VK_KHR_surface</computeroutput>, so if you don&apos;t require any additional extensions you can pass this list directly to the <computeroutput><ref refid="struct_vk_instance_create_info" kindref="compound">VkInstanceCreateInfo</ref></computeroutput> struct.</para>
<para><programlisting><codeline><highlight class="normal"><ref refid="struct_vk_instance_create_info" kindref="compound">VkInstanceCreateInfo</ref><sp/>ici;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">memset(&amp;ici,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(ici));</highlight></codeline>
<codeline><highlight class="normal">ici.enabledExtensionCount<sp/>=<sp/>count;</highlight></codeline>
<codeline><highlight class="normal">ici.ppEnabledExtensionNames<sp/>=<sp/>extensions;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
</programlisting></para>
<para>Additional extensions may be required by future versions of GLFW. You should check whether any extensions you wish to enable are already in the returned array, as it is an error to specify an extension more than once in the <computeroutput><ref refid="struct_vk_instance_create_info" kindref="compound">VkInstanceCreateInfo</ref></computeroutput> struct.</para>
</sect1>
<sect1 id="vulkan_guide_1vulkan_present">
<title>Querying for Vulkan presentation support</title>
<para>Not every queue family of every Vulkan device can present images to surfaces. To check whether a specific queue family of a physical device supports image presentation without first having to create a window and surface, call glfwGetPhysicalDevicePresentationSupport.</para>
<para><programlisting><codeline><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(glfwGetPhysicalDevicePresentationSupport(instance,<sp/>physical_device,<sp/>queue_family_index))</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Queue<sp/>family<sp/>supports<sp/>image<sp/>presentation</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The <computeroutput>VK_KHR_surface</computeroutput> extension additionally provides the <computeroutput>vkGetPhysicalDeviceSurfaceSupportKHR</computeroutput> function, which performs the same test on an existing Vulkan surface.</para>
</sect1>
<sect1 id="vulkan_guide_1vulkan_window">
<title>Creating the window</title>
<para>Unless you will be using OpenGL or OpenGL ES with the same window as Vulkan, there is no need to create a context. You can disable context creation with the <ref refid="window_guide_1GLFW_CLIENT_API_hint" kindref="member">GLFW_CLIENT_API</ref> hint.</para>
<para><programlisting><codeline><highlight class="normal"><ref refid="group__window_1ga69c40728499720bef8a49aa925ea0efa" kindref="member">glfwWindowHint</ref>(<ref refid="group__window_1ga649309cf72a3d3de5b1348ca7936c95b" kindref="member">GLFW_CLIENT_API</ref>,<sp/>GLFW_NO_API);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__window_1ga3c96d80d363e67d13a41b5d1821f3242" kindref="member">GLFWwindow</ref>*<sp/>window<sp/>=<sp/><ref refid="group__window_1gaaccd00fafe81e2db94e8cdf55721e055" kindref="member">glfwCreateWindow</ref>(640,<sp/>480,<sp/></highlight><highlight class="stringliteral">&quot;Window<sp/>Title&quot;</highlight><highlight class="normal">,<sp/>NULL,<sp/>NULL);</highlight></codeline>
</programlisting></para>
<para>See <ref refid="context_guide_1context_less" kindref="member">Windows without contexts</ref> for more information.</para>
</sect1>
<sect1 id="vulkan_guide_1vulkan_surface">
<title>Creating a Vulkan window surface</title>
<para>You can create a Vulkan surface (as defined by the <computeroutput>VK_KHR_surface</computeroutput> extension) for a GLFW window with glfwCreateWindowSurface.</para>
<para><programlisting><codeline><highlight class="normal">VkSurfaceKHR<sp/>surface;</highlight></codeline>
<codeline><highlight class="normal">VkResult<sp/>err<sp/>=<sp/>glfwCreateWindowSurface(instance,<sp/>window,<sp/>NULL,<sp/>&amp;surface);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(err)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Window<sp/>surface<sp/>creation<sp/>failed</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>If an OpenGL or OpenGL ES context was created on the window, the context has ownership of the presentation on the window and a Vulkan surface cannot be created.</para>
<para>It is your responsibility to destroy the surface. GLFW does not destroy it for you. Call <computeroutput>vkDestroySurfaceKHR</computeroutput> function from the same extension to destroy it. </para>
</sect1>
    </detaileddescription>
    <location file="/Users/cwb/developer/learning/graphicRenderEngine/ceres/3rdparty/glfw/docs/vulkan.dox"/>
  </compounddef>
</doxygen>
