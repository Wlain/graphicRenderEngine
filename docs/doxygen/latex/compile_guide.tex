This is about compiling the GLFW library itself. For information on how to build applications that use GLFW, see \mbox{\hyperlink{build_guide}{Building applications}}.\hypertarget{compile_guide_compile_cmake}{}\doxysection{Using CMake}\label{compile_guide_compile_cmake}
GLFW uses \href{https://cmake.org/}{\texttt{ CMake}} to generate project files or makefiles for a particular development environment. If you are on a Unix-\/like system such as Linux or Free\+BSD or have a package system like Fink, Mac\+Ports, Cygwin or Homebrew, you can install its CMake package. If not, you can download installers for Windows and mac\+OS from the \href{https://cmake.org/}{\texttt{ CMake website}}.

\begin{DoxyNote}{Note}
CMake only generates project files or makefiles. It does not compile the actual GLFW library. To compile GLFW, first generate these files for your chosen development environment and then use them to compile the actual GLFW library.
\end{DoxyNote}
\hypertarget{compile_guide_compile_deps}{}\doxysubsection{Dependencies}\label{compile_guide_compile_deps}
Once you have installed CMake, make sure that all other dependencies are available. On some platforms, GLFW needs a few additional packages to be installed. See the section for your chosen platform and development environment below.\hypertarget{compile_guide_compile_deps_msvc}{}\doxysubsubsection{Dependencies for Visual C++ on Windows}\label{compile_guide_compile_deps_msvc}
The Windows SDK bundled with Visual C++ already contains all the necessary headers, link libraries and tools except for CMake. Move on to \mbox{\hyperlink{compile_guide_compile_generate}{Generating build files with CMake}}.\hypertarget{compile_guide_compile_deps_mingw}{}\doxysubsubsection{Dependencies for Min\+GW or Min\+GW-\/w64 on Windows}\label{compile_guide_compile_deps_mingw}
Both the Min\+GW and the Min\+GW-\/w64 packages already contain all the necessary headers, link libraries and tools except for CMake. Move on to \mbox{\hyperlink{compile_guide_compile_generate}{Generating build files with CMake}}.\hypertarget{compile_guide_compile_deps_mingw_cross}{}\doxysubsubsection{Dependencies for Min\+GW or Min\+GW-\/w64 cross-\/compilation}\label{compile_guide_compile_deps_mingw_cross}
Both Cygwin and many Linux distributions have Min\+GW or Min\+GW-\/w64 packages. For example, Cygwin has the {\ttfamily mingw64-\/i686-\/gcc} and {\ttfamily mingw64-\/x86\+\_\+64-\/gcc} packages for 32-\/ and 64-\/bit version of Min\+GW-\/w64, while Debian GNU/\+Linux and derivatives like Ubuntu have the {\ttfamily mingw-\/w64} package for both.

GLFW has CMake toolchain files in the {\ttfamily CMake/} directory that set up cross-\/compilation of Windows binaries. To use these files you add an option when running {\ttfamily cmake} to generate the project files or makefiles\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{cmake -\/DCMAKE\_TOOLCHAIN\_FILE=<toolchain-\/file> .}

\end{DoxyCode}


The exact toolchain file to use depends on the prefix used by the Min\+GW or Min\+GW-\/w64 binaries on your system. You can usually see this in the /usr directory. For example, both the Debian/\+Ubuntu and Cygwin Min\+GW-\/w64 packages have {\ttfamily /usr/x86\+\_\+64-\/w64-\/mingw32} for the 64-\/bit compilers, so the correct invocation would be\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{cmake -\/DCMAKE\_TOOLCHAIN\_FILE=CMake/x86\_64-\/w64-\/mingw32.cmake .}

\end{DoxyCode}


For more details see the article \href{https://gitlab.kitware.com/cmake/community/wikis/doc/cmake/CrossCompiling}{\texttt{ CMake Cross Compiling}} on the CMake wiki.

Once you have this set up, move on to \mbox{\hyperlink{compile_guide_compile_generate}{Generating build files with CMake}}.\hypertarget{compile_guide_compile_deps_xcode}{}\doxysubsubsection{Dependencies for Xcode on mac\+OS}\label{compile_guide_compile_deps_xcode}
Xcode comes with all necessary tools except for CMake. The required headers and libraries are included in the core mac\+OS frameworks. Xcode can be downloaded from the Mac App Store or from the ADC Member Center.

Once you have Xcode installed, move on to \mbox{\hyperlink{compile_guide_compile_generate}{Generating build files with CMake}}.\hypertarget{compile_guide_compile_deps_x11}{}\doxysubsubsection{Dependencies for Linux and X11}\label{compile_guide_compile_deps_x11}
To compile GLFW for X11, you need to have the X11 packages installed, as well as the basic development tools like GCC and make. For example, on Ubuntu and other distributions based on Debian GNU/\+Linux, you need to install the {\ttfamily xorg-\/dev} package, which pulls in all X.\+org header packages.

Once you have installed the necessary packages, move on to \mbox{\hyperlink{compile_guide_compile_generate}{Generating build files with CMake}}.\hypertarget{compile_guide_compile_deps_wayland}{}\doxysubsubsection{Dependencies for Linux and Wayland}\label{compile_guide_compile_deps_wayland}
To compile GLFW for Wayland, you need to have the Wayland packages installed, as well as the basic development tools like GCC and make. For example, on Ubuntu and other distributions based on Debian GNU/\+Linux, you need to install the {\ttfamily libwayland-\/dev} package, which contains all Wayland headers and pulls in wayland-\/scanner, as well as the {\ttfamily wayland-\/protocols} package.

Once you have installed the necessary packages, move on to \mbox{\hyperlink{compile_guide_compile_generate}{Generating build files with CMake}}.\hypertarget{compile_guide_compile_deps_osmesa}{}\doxysubsection{Dependencies for Linux and OSMesa}\label{compile_guide_compile_deps_osmesa}
To compile GLFW for OSMesa, you need to install the OSMesa library and header packages. For example, on Ubuntu and other distributions based on Debian GNU/\+Linux, you need to install the {\ttfamily libosmesa6-\/dev} package. The OSMesa library is required at runtime for context creation and is loaded on demand.

Once you have installed the necessary packages, move on to \mbox{\hyperlink{compile_guide_compile_generate}{Generating build files with CMake}}.\hypertarget{compile_guide_compile_generate}{}\doxysubsection{Generating build files with CMake}\label{compile_guide_compile_generate}
Once you have all necessary dependencies it is time to generate the project files or makefiles for your development environment. CMake needs to know two paths for this\+: the path to the {\itshape root} directory of the GLFW source tree (i.\+e. {\itshape not} the {\ttfamily src} subdirectory) and the target path for the generated files and compiled binaries. If these are the same, it is called an in-\/tree build, otherwise it is called an out-\/of-\/tree build.

One of several advantages of out-\/of-\/tree builds is that you can generate files and compile for different development environments using a single source tree.

\begin{DoxyNote}{Note}
This section is about generating the project files or makefiles necessary to compile the GLFW library, not about compiling the actual library.
\end{DoxyNote}
\hypertarget{compile_guide_compile_generate_cli}{}\doxysubsubsection{Generating files with the CMake command-\/line tool}\label{compile_guide_compile_generate_cli}
To make an in-\/tree build, enter the {\itshape root} directory of the GLFW source tree (i.\+e. {\itshape not} the {\ttfamily src} subdirectory) and run CMake. The current directory is used as target path, while the path provided as an argument is used to find the source tree.


\begin{DoxyCode}{0}
\DoxyCodeLine{cd <glfw-\/root-\/dir>}
\DoxyCodeLine{cmake .}

\end{DoxyCode}


To make an out-\/of-\/tree build, make a directory outside of the source tree, enter it and run CMake with the (relative or absolute) path to the root of the source tree as an argument.


\begin{DoxyCode}{0}
\DoxyCodeLine{mkdir glfw-\/build}
\DoxyCodeLine{cd glfw-\/build}
\DoxyCodeLine{cmake <glfw-\/root-\/dir>}

\end{DoxyCode}


Once you have generated the project files or makefiles for your chosen development environment, move on to \mbox{\hyperlink{compile_guide_compile_compile}{Compiling the library}}.\hypertarget{compile_guide_compile_generate_gui}{}\doxysubsubsection{Generating files with the CMake GUI}\label{compile_guide_compile_generate_gui}
If you are using the GUI version, choose the root of the GLFW source tree as source location and the same directory or another, empty directory as the destination for binaries. Choose {\itshape Configure}, change any options you wish to, {\itshape Configure} again to let the changes take effect and then {\itshape Generate}.

Once you have generated the project files or makefiles for your chosen development environment, move on to \mbox{\hyperlink{compile_guide_compile_compile}{Compiling the library}}.\hypertarget{compile_guide_compile_compile}{}\doxysubsection{Compiling the library}\label{compile_guide_compile_compile}
You should now have all required dependencies and the project files or makefiles necessary to compile GLFW. Go ahead and compile the actual GLFW library with these files, as you would with any other project.

Once the GLFW library is compiled, you are ready to build your applications, linking it to the GLFW library. See \mbox{\hyperlink{build_guide}{Building applications}} for more information.\hypertarget{compile_guide_compile_options}{}\doxysubsection{CMake options}\label{compile_guide_compile_options}
The CMake files for GLFW provide a number of options, although not all are available on all supported platforms. Some of these are de facto standards among projects using CMake and so have no {\ttfamily GLFW\+\_\+} prefix.

If you are using the GUI version of CMake, these are listed and can be changed from there. If you are using the command-\/line version of CMake you can use the {\ttfamily ccmake} ncurses GUI to set options. Some package systems like Ubuntu and other distributions based on Debian GNU/\+Linux have this tool in a separate {\ttfamily cmake-\/curses-\/gui} package.

Finally, if you don\textquotesingle{}t want to use any GUI, you can set options from the {\ttfamily cmake} command-\/line with the {\ttfamily -\/D} flag.


\begin{DoxyCode}{0}
\DoxyCodeLine{cmake -\/DBUILD\_SHARED\_LIBS=ON .}

\end{DoxyCode}
\hypertarget{compile_guide_compile_options_shared}{}\doxysubsubsection{Shared CMake options}\label{compile_guide_compile_options_shared}
\label{compile_guide_BUILD_SHARED_LIBS}%
\Hypertarget{compile_guide_BUILD_SHARED_LIBS}%
{\bfseries{BUILD\+\_\+\+SHARED\+\_\+\+LIBS}} determines whether GLFW is built as a static library or as a DLL / shared library / dynamic library.

\label{compile_guide_GLFW_BUILD_EXAMPLES}%
\Hypertarget{compile_guide_GLFW_BUILD_EXAMPLES}%
{\bfseries{GLFW\+\_\+\+BUILD\+\_\+\+EXAMPLES}} determines whether the GLFW examples are built along with the library. This is enabled by default unless GLFW is being built as a sub-\/project.

\label{compile_guide_GLFW_BUILD_TESTS}%
\Hypertarget{compile_guide_GLFW_BUILD_TESTS}%
{\bfseries{GLFW\+\_\+\+BUILD\+\_\+\+TESTS}} determines whether the GLFW test programs are built along with the library. This is enabled by default unless GLFW is being built as a sub-\/project.

\label{compile_guide_GLFW_BUILD_DOCS}%
\Hypertarget{compile_guide_GLFW_BUILD_DOCS}%
{\bfseries{GLFW\+\_\+\+BUILD\+\_\+\+DOCS}} determines whether the GLFW documentation is built along with the library.

\label{compile_guide_GLFW_VULKAN_STATIC}%
\Hypertarget{compile_guide_GLFW_VULKAN_STATIC}%
{\bfseries{GLFW\+\_\+\+VULKAN\+\_\+\+STATIC}} determines whether to use the Vulkan loader linked directly with the application.\hypertarget{compile_guide_compile_options_win32}{}\doxysubsubsection{Windows specific CMake options}\label{compile_guide_compile_options_win32}
\label{compile_guide_USE_MSVC_RUNTIME_LIBRARY_DLL}%
\Hypertarget{compile_guide_USE_MSVC_RUNTIME_LIBRARY_DLL}%
{\bfseries{USE\+\_\+\+MSVC\+\_\+\+RUNTIME\+\_\+\+LIBRARY\+\_\+\+DLL}} determines whether to use the DLL version or the static library version of the Visual C++ runtime library. If set to {\ttfamily ON}, the DLL version of the Visual C++ library is used.

\label{compile_guide_GLFW_USE_HYBRID_HPG}%
\Hypertarget{compile_guide_GLFW_USE_HYBRID_HPG}%
{\bfseries{GLFW\+\_\+\+USE\+\_\+\+HYBRID\+\_\+\+HPG}} determines whether to export the {\ttfamily Nv\+Optimus\+Enablement} and {\ttfamily Amd\+Power\+Xpress\+Request\+High\+Performance} symbols, which force the use of the high-\/performance GPU on Nvidia Optimus and AMD Power\+Xpress systems. These symbols need to be exported by the EXE to be detected by the driver, so the override will not work if GLFW is built as a DLL.\hypertarget{compile_guide_compile_manual}{}\doxysection{Compiling GLFW manually}\label{compile_guide_compile_manual}
If you wish to compile GLFW without its CMake build environment then you will have to do at least some of the platform detection yourself. GLFW needs a configuration macro to be defined in order to know what window system it\textquotesingle{}s being compiled for and also has optional, platform-\/specific ones for various features.

When building with CMake, the {\ttfamily glfw\+\_\+config.\+h} configuration header is generated based on the current platform and CMake options. The GLFW CMake environment defines {\bfseries{GLFW\+\_\+\+USE\+\_\+\+CONFIG\+\_\+H}}, which causes this header to be included by {\ttfamily \mbox{\hyperlink{internal_8h_source}{internal.\+h}}}. Without this macro, GLFW will expect the necessary configuration macros to be defined on the command-\/line.

The window creation API is used to create windows, handle input, monitors, gamma ramps and clipboard. The options are\+:


\begin{DoxyItemize}
\item {\bfseries{\+\_\+\+GLFW\+\_\+\+COCOA}} to use the Cocoa frameworks
\item {\bfseries{\+\_\+\+GLFW\+\_\+\+WIN32}} to use the Win32 API
\item {\bfseries{\+\_\+\+GLFW\+\_\+\+X11}} to use the X Window System
\item {\bfseries{\+\_\+\+GLFW\+\_\+\+WAYLAND}} to use the Wayland API (experimental and incomplete)
\item {\bfseries{\+\_\+\+GLFW\+\_\+\+OSMESA}} to use the OSMesa API (headless and non-\/interactive)
\end{DoxyItemize}

If you are building GLFW as a shared library / dynamic library / DLL then you must also define {\bfseries{\+\_\+\+GLFW\+\_\+\+BUILD\+\_\+\+DLL}}. Otherwise, you must not define it.

If you are linking the Vulkan loader directly with your application then you must also define {\bfseries{\+\_\+\+GLFW\+\_\+\+VULKAN\+\_\+\+STATIC}}. Otherwise, GLFW will attempt to use the external version.

If you are using a custom name for the Vulkan, EGL, GLX, OSMesa, Open\+GL, GLESv1 or GLESv2 library, you can override the default names by defining those you need of {\bfseries{\+\_\+\+GLFW\+\_\+\+VULKAN\+\_\+\+LIBRARY}}, {\bfseries{\+\_\+\+GLFW\+\_\+\+EGL\+\_\+\+LIBRARY}}, {\bfseries{\+\_\+\+GLFW\+\_\+\+GLX\+\_\+\+LIBRARY}}, {\bfseries{\+\_\+\+GLFW\+\_\+\+OSMESA\+\_\+\+LIBRARY}}, {\bfseries{\+\_\+\+GLFW\+\_\+\+OPENGL\+\_\+\+LIBRARY}}, {\bfseries{\+\_\+\+GLFW\+\_\+\+GLESV1\+\_\+\+LIBRARY}} and {\bfseries{\+\_\+\+GLFW\+\_\+\+GLESV2\+\_\+\+LIBRARY}}. Otherwise, GLFW will use the built-\/in default names.

For the EGL context creation API, the following options are available\+:


\begin{DoxyItemize}
\item {\bfseries{\+\_\+\+GLFW\+\_\+\+USE\+\_\+\+EGLPLATFORM\+\_\+H}} to use an existing {\ttfamily EGL/eglplatform.\+h} header file for native handle types (fallback)
\end{DoxyItemize}

\begin{DoxyNote}{Note}
None of the \mbox{\hyperlink{build_guide_build_macros}{GLFW header option macros}} may be defined during the compilation of GLFW. If you define any of these in your build files, make sure they are not applied to the GLFW sources. 
\end{DoxyNote}
